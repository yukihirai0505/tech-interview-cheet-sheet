# エンジニア技術面接チートシート

各項目について

- 使い方
- 実装方法
- 使いどころ
- 空間・時間計算量がどれくらいか

などを確実に理解しておくべき

## 1. データ構造(データストラクチャー)

- [連結リスト](#連結リスト)
- [木・トライ木・グラフ](#木とグラフ)
- [スタックとキュー](#スタックとキュー)
- ヒープ
- [ベクタ/配列リスト](#配列リスト)
- [ハッシュテーブル](#ハッシュテーブル)

### 連結リスト

連結リストは、ノードの並びを表すデータ構造。

片方向連結リストでは、各ノードは次のノードの位置を指し示す。

双方向連結リストでは、各ノードは次のノードと前のノードの位置を指し示す。

配列とは異なり、連結リストには特定のインデックスに一定時間でアクセスする機能を備えていない。

リスト内のK番目の要素を見つけたい場合はK個分の要素を走査する必要がある。

単方向連結リストからノードを削除するのは簡単。

ノードnが与えられたとき、1つ前のノードprevを探し、
prev,nextをn,nextに置き換えるだけ。

双方向連結リストであれば
n.next.prevとn.prevが同じになるようにセットすることも合わせて必要。

## 木とグラフ

### 木

#### 二分木と二分探索木

二分木は各ノードが最大2個の子をもつ木。

二分探索木はすべてのノードが特定の並び順(すべての左の子孫<=n<=すべての右の子孫)になっている二分木のこと。

#### 平衡と非平衡

平衡木は左右の部分木がちょうど同じサイズという意味ではない。
平衡木というのは「極端にアンバランスではない」ものと考えておくと良い。

データの追加や検索がO(log n)の時間で実行できれば十分で、その程度にバランスが取れていれば問題ない。

- 完全二分木(Complete Binary Tree) => 一番深いノードまでの範囲で満たされているという場合左から右の順にノードが埋まっているもの
- 全二分木(Full Binary Tree) => すべてのノードが0個か2個の子をもつ二分木。子を1つだけしか持たないノードは1つもない
- 完全二分木(Perfect Binary Tree) => すべての葉ノードは同じ深さで、もっとも深い部分のノード数が最大になっている

完全二分木はちょうど2^k-1個のノードを持つ

二分木の走査には

- in-order
- pre-order
- post-order

の三種類がある。

#### 二分ヒープ(最小ヒープと最大ヒープ)

最小ヒープは、すべてのノードが子ノードよりも小さい完全二分木(Complete Binary Tree)。

最小ヒープに挿入を行う際は、常に最後の部分に要素を追加するところから始める。

最深部のもっとも右側に追加し、完全木の特性を維持するため。

次に最適な位置が見つかるまで、新たに加えたノードと親ノードを入れ替えることで木を修正する。

nをヒープ内のノード数とすると実行時間はO(log n)になる。

最小要素の取り出しもO(log n)になる。
最小と最大値を入れ替えて、最大値を適した位置に入れ替えていく。

#### トライ木

トライ木は各ノードに文字が保持されるn分木の一種で木を降る経路が単語を表している。

正しい単語のリストを含む問題の多くは、最適化としてトライ木を利用する。
文字列の接頭部を繰り返し検索する状況では、現在のノードにそれまでの経路の参照を渡すようにしておくと良い。

### グラフ

木は実質的にグラフの一種だが、すべてのグラフが木であるわけではない。
木は閉鎖なしの連結グラフ。

グラフは、単純にノード同士に編をもったものの集まりのこと。

- グラフは有向のものと無向のものがある。有向の辺は一方通行で、無向の辺は双方通行の通りのようなもの
- グラフは複数の孤立した部分グラフから成り立っている場合もある。どの2頂点同士にも経路が存在する場合は「連結グラフ」という
- グラフは閉路を持つ場合も持たない場合もある。非巡回グラフは閉路をもたないグラフ

#### 隣接リスト

全ての頂点(ノード)は隣接する頂点のリストをもつ。
無向グラフでは(a, b)のように辺が2回保持される。
1回はaの隣接点で、もう1回はbの隣接点。

グラフは木と異なり、単一のノードからすべてのノードに必ず到達するとは限らない

#### 隣接行列

隣接行列はN×Nのブーリアン型


#### グラフ探索

- 深さ優先探索(DFS: depth-first search)
=> 根から探索を開始し次の枝に移る前に各枝を完全に探索する
=> 横方向の探索よりも先に縦方向(より深い方向)の探索を行う

- 幅優先探索(BFS: breadth-first search)
=> 根から探索を開始し子ノードの探索を行う前に隣接するノードを探索する
=> 縦方向の探索よりも先に横方向(幅広い方向)の探索を行う

幅優先探索と深さ優先探索はそれぞれ異なった状況で
使われる傾向がある。

深さ優先探索はグラフのすべてのノードを走査したい場合に好まれる
深さ優先探索の方がやや単純

2つのノード間の最短経路(あるいは任意の経路)を求めたい場合は一般的に幅優先探索が適している。

##### 深さ優先探索

DFSではノードaを訪れてから隣接するノードを走査する
ノードaに隣接するノードbを訪れる時
aに隣接するb以外のノードの前にbを隣接するすべてのノードを訪れる

pre-orderや他の木の走査はDFSの一形態。
グラフに対してこのアルゴリズムを実装するときの重要な違いは、ノードをすでに訪れたかどうかチェックしなければならないところ

pseudocode

```
void search(Node root) {
    if (root == null) return;
    visit(root);
    root.visited = true;
    for each (Node n in root.adjacent) {
        if (n.visited == false) {
            search(n);
        }
    }
}
```

***双方向探索***

双方向探索は元になるノードと目的のノードの最短経路を見つけるために使われる
基本的には幅優先探索を元のノードと目的地のノードの二箇所から同時に行う

##### 幅優先探索

BFSは慣れていないと実装に苦労する
つまずきやすいのはBFSが再帰的であると(間違って)考えてしまうところ。
この場合は再帰ではなく、キューを使う。

BFSでは、ノードaは、aに隣接するノードの各隣接ノードを訪れる前にaの隣接ノードを訪れる
ノードの深さごとと考えてもよし

```
void search(Node root) {
    Queue queue = new Queue();
    root.marked = true;
    queue.enqueue(root);

    while(!queue.isEmpty()) {
        Node r = queue.dequeue();
        foreach(Node n in r.adjacent) {
            if (n.marked == false) {
                n.marked = true;
                queue.enqueue(n);
            }
        }
    }
}
```

### スタックとキュー

#### スタック

スタックは、データが積み重なったLIFO(後入れ先出し)データ構造。
スタックは次の操作を行う。

- pop(): スタックの一番上からデータを削除する
- push(item): スタックの一番上に要素itemを追加する
- peek(): スタックの一番上の要素を返す
- isEmpty(): スタックが空の場合にのみtrueを返す

配列とは異なり、i番目の要素に一定時間でアクセスできない

シフト操作は必要ないので、追加と削除は一定時間でできる

スタックは特定の再帰アルゴリズムを用いる場合に役立つ

#### キュー

キューはFIFO(先入れ先出し)のデータ構造を実現したもの。

キューは次の操作を行う。

- add(item): 要素をリストの最後に追加する
- remove(): 先頭の要素を削除する
- peek(): 先頭の要素を返す
- isEmpty(): キューが空の場合のみtrueを返す

キューが頻繁に利用されるのは幅優先探索や、キャッシュの実装。

例えば幅優先探索では、処理する必要があるノードのリストを格納するキューを使用。

ノードを処理する度に、隣接ノードをキューの末尾に追加する。

これにより、ノードが出現する順序でノードを処理できる。

### ハッシュテーブル

効率的な検索を行うために、キーを値にマップするデータ構造。

実装方法は多々ある。

単純な実装では、連結リストの配列とハッシュ関数を用いる。

1. キーのハッシュ値を計算
    - 異なる2つのキーが同じハッシュ値をもつ場合がある
2. ハッシュ値を配列のインデックスに対応させる
    - ex) hash(key) % (配列の長さ)
    - 異なる2つのハッシュ値が同じインデックスに対応することがある
3. キーと値の連結リストがインデックスに保存される

キーから値のペアを検索するには、
キーからハッシュ値を計算し、ハッシュ値からインデックスを計算して、
キーに対応する値を連結リストから探します

衝突数が大きい場合は、Nをキーの数とすると
実行時間の最悪ケースはO(N)になる
一般的にはうまく実装して衝突が最小限に抑えられると考えられる
その場合は探索時間はO(1)になる

ハッシュテーブルを二分探索木で実装することもでき、
その場合は検索がO(log N)で済む

### 配列リスト

動的にサイズを変えることができるようなデータ構造が必要になるとき、
通常は配列リスト(可変長配列)は計算量O(1)でアクセスを備えつつ、自信のサイズを必要に応じて変更できる

一般的な実装は、配列がいっぱいになったときにサイズを2倍にするというもの

サイズを増やす処理自体はO(n)の計算量だが
実際にこの処理が行われることはほとんどないのでならしでO(1)となる

## 2. アルゴリズム

- 幅優先探索
- 深さ優先探索
- 二分木
- マージソート
- クイックソート

### マージソート

並列で処理が可能なため、メモリとCPUの並列数が豊富な場合に使用

### クイックソート

一般的に高速なアルゴリズムのため使用される機会が多い



## 3. 概念

- ビット操作
- メモリ(スタックvsヒープ)
- [再帰](#再帰)
- 動的計画法
- ビッグ・オー記法、スペース

### 再帰

再帰的なアルゴリズムは再帰の深さをnとすると、
少なくともメモリ使用量がO(n)になってしまう

## 参考

- [CRACKING the CODING INTERVIEW](http://www.crackingthecodinginterview.com/)
